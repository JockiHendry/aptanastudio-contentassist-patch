package com.aptana.editor.coffee.parsing;

import java.util.ArrayList;
import java.util.List;

import beaver.Parser;
import beaver.ParsingTables;
import beaver.Scanner;
import beaver.Symbol;

import com.aptana.editor.coffee.ICoffeeConstants;
import com.aptana.editor.coffee.parsing.ast.CoffeeAccessNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeArrNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeAssignNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeBlockNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeCallNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeCatchNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeClassNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeCodeNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeCommentNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeExistenceNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeExtendsNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeForNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeForSourceNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeForVariablesNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeIfNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeIndexNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeLiteralNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeObjNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeOpNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeParamNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeParensNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeParseRootNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeRangeNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeReturnNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeSliceNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeSplatNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeSwitchNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeThrowNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeTryNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeValueNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeWhenNode;
import com.aptana.editor.coffee.parsing.ast.CoffeeWhileNode;
import com.aptana.editor.coffee.parsing.lexer.CoffeeScanner;
import com.aptana.parsing.IParseState;
import com.aptana.parsing.IParser;
import com.aptana.parsing.ParseResult;
import com.aptana.parsing.WorkingParseResult;
import com.aptana.parsing.ast.IParseError;
import com.aptana.parsing.ast.IParseNode;
import com.aptana.parsing.ast.ParseError;
import com.aptana.parsing.ast.ParseRootNode;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "coffee.grammar".
 */
@SuppressWarnings({ "unchecked", "rawtypes", "nls" })
public class CoffeeParser extends Parser implements IParser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjMmTy55KJdysb44hkBY3ILKvA4Y0QUf4gJGH4UfUU42G20G8IGQe51IoeOA#87R6WQ4G" +
		"H2ofM5445516iW28YCD$$bTlTI#wE#xuzVX$wE$pDpfltPlupRzvxixktaIXr9BrDcwa9BQ" +
		"QRwJQwdUwWF7gQMjF5D8ukfubq1JrCSoc1NgH2Uf0Uec4qd2wZ4JIIHj5e6aDZwLsZ1TMZl" +
		"sWNhQP4IWBMBFg1uW8GhwSRw2QwHIDMfkfq3hUEo7CZU7ubb6UQG$sCQjIDpgMsr8Ooeu1O" +
		"cjmIKSP85qObnj8IKUMcIqI8WyCYscqVjMUMLneDQ03TI4lfFBg4BgK#r5$CY0OQzIFo#rX" +
		"Olr$hRDU9LhQDSXgngq0qQaGXs$lfHse8nAZi1BeeGgJmvwEEKTT8CzAfdc7WbDJ7#MXACw" +
		"E7QsGOFcfF#S1jHtSxnwKq8uxIASEe2TokHX9mzz1zpBIGhj7deXxTAi$xGJf4Tz4AMabtq" +
		"YJQIKVe9xa2rz4gUf#cq9VqAZr2lzDX#fNcymcgImLHYC#VHtMYN1JlD3BgY7bM3uZf6$hA" +
		"Lh6K9x4Z6ZZrPPn7xOlxCihQV8L2xOcH3evd6iAALr8lNJdg#Ik7KK$DswZgs6jlh5draBO" +
		"gk#hQ89BzONZ2djnGSooYlbma$gDcYdEHqOG#ZsX77WZhyRU8C9B3OaI2KDOnGefZXF2vZm" +
		"GXrJ521SS85HqZL7ACKCKnGZN723KS8vpj6A6vOuIMZX4k28lWzCwtWWQX$ZcjeWNsIecA$" +
		"OQgsCQvvhFUcqOjlZ6Y#GuzbVEbR3oFZ8yeZXp7AvTxIcTYlpTDfcaq8wAOhdOygmME4HOv" +
		"HhZsb6QsWARJlH75yUGfZcCUFHTH76iTP$HvnmWldz9SBC6xQcf4SNpWU2RR72FiSupmyod" +
		"DvZBOHVQ#yuVZcVpf6E5lfmX6#ESPfzbSJW$W7Xf97BKTpoJJCK93nmYD7ICqTOmG$idCwO" +
		"h6x6FsCVkOVSm#PX#pZzd7xFzvzkgNaV$DlXoLqVuLYYaRzfvGsElazvYfvAKpgJoTGQNaj" +
		"zjADhb0zF1JeiUe9xyQ5HXL9SuGUjpyjd54UYcY7VPdOICvu8jro4ZfDUeiuzXk#isIevR6" +
		"CxH6Qcm8Z9GwsMHBku0Qor4H#HARnWIZSeaedaLkNfTVmeJ5Iq7nheIEI#h8RD1JDgqNIY2" +
		"gwnDIio0eNZ#jquEwQyGjGVNiU1l3uAKXldJAeFkf9k8KUfjiUiTicbVHR1DHwBqL0gz0uX" +
		"LGRRw1tf6QlfD6ABHS0Jkde8HcRRg7lf2QjKnDIqTzExFagbBplI2Q$RIk#8OkTCugjY#s1" +
		"erMZ7mMPXvsV1MxM25XzObbPQJ8aK#DU3doRJ7FzKnPd2IlANse4FaZ$b3kooBowkzeBVpV" +
		"qNGKHuqiMcwKmPamepAyy9Ob4SkRY2h2y#c4GKOYhoJMlsINDd$9Faxh3NaAg5L03hSY2x2" +
		"I8#mVCHf9JwLWjHU#5Vfkew9njj4CljL9FrFQT3NHLEzPz3q$2IiHNqlx$FcuNq9yl#Wr8t" +
		"zywACIVKL4EXjavaL4Wd#yKLob9FUnb4LED#fC1P6aXOYPx765bJuACIQoKm6v#zYCGkIGZ" +
		"3Zaa6Hxgt46sdiW7JTZiDgX$H9z1vnIu7jrHXCC5zgYsWeIrLQG7$E8934Y$baZwdeaG5BN" +
		"pbOynlcuP0NH4N#dSJ7sUm$gYTNeXVNeZHNfYxFG7wiqa0RHODJyeK5#nHX7sPH3uoaNIEr" +
		"m3f8rrXJgWdjBQ4JnLmS9k0CwzroN9iYxJ2VSPoRHv2WWdeDQAX1LZD50h0jCWQYGee4OsZ" +
		"QTPg0IrQS6b4VdeKPaKKCve$cq82hhhBAT6RLiHn#n0iwObUrex8JehPSuR#AKJA5vE1$Hm" +
		"or4NKodES0jY1AkpyJDn5F153mJJ1KbXEBqkV3Ff3IgOLdKn1HKDG#gMYggcbY1YgXlbN1F" +
		"hO9xUJNSMMlWJdqs46O2sNbyVkyAAGFnEOqi3$FqXOb9UH8xeaaKVAM7zHKALNp1RkFOUoY" +
		"hT4IaAaUYMJcQwdctTEorE#ny8MsL5tMDnltev7DiRywnCysDIXrpZX53Y27444vF1AVrBv" +
		"qQeVuvHV45LCfql0MhQjRKh6PTwG9u#l$Fzm9vZ$ith9mzumNmbdPQpEfqG72#ctEZiaTEb" +
		"pXE1mIdkPY0Pzn$IovEXsmcnh8PjMnsfrQnR9vM24vND6OViu$Pn#nZzZ7xc7tCFcR$pxDN" +
		"Jv5E$IiKIywqzOJ2RYw$nrn8vr8jgarrv7VMcdYNjsIVx6aaUvfA71#rb3WpRDysKgMNN6e" +
		"HvbauTAHNQo#MtmmvQcc8kGkDjiKYRMEJBMqV8XEZLkHA8mtn5O#Y0#QKAtCZjCi7nKk3Je" +
		"RKyUdlLtRCueZgEaDg#eBYJT0wudkjBuoU7IytZ9xuCYHodeQSPqYzxX54M7obxNZgswMFP" +
		"Y9$olFiaqOej382TewlXEPCl7zc5iEpTDGliPRSk5YCzWmgNP51eTEusBve5ZHQCJ8zp3pi" +
		"#2fsFxuzJxbo94tF8w#OvqHJ3lGsIoFwz8gdOqJDeR7voxEAmaUjiG8jpFTqOJKTtjJApZ8" +
		"H5LuJUUB4zz1U6Y$Nn1k4jh9g7P33Pi0JLcAabpdIM8xbmsgQkNPN0Y4D8nawbZHfasdQgD" +
		"uyM3M2LU0E41APKZgGP7pCPdpfQ4VIXqWO$yWdhrR5pD2IhdHQQcANf0KYmTKMLpW9Smm#f" +
		"bQz6JKteq0EHLJK2rUHJumXdoAgGVuOh7Pel#0TGVcWQLet7vcV9gkj855j1VddbIf8Z4Xy" +
		"SqHVKmCa$vwouaa3PGJH8QFL7Fb7KN4LG8s9IbTJigU7uAfTkXNa4Rez19UnuBF0ju3V2Ru" +
		"KV3sHUnNu3l3kuCU8l4U8obI3xM5mWJ4D7FPkG9M1lUTwSDXx#m2ZckNF$ONYj1$j$Vv#Eo" +
		"5M7OzH7lP9gbrclRPVfhYhcUv7J9vzu2AcLAAoYCax4WDQtrYdCM$JyavW5AfsmZBq8xwoh" +
		"Mo#jsc#HFCjsb#SvlKjtOHhCBuLVBQE3Nb8M0j#Hx1vbPndmiz4YSc8DmSnYDoj3gwNQEZO" +
		"du9ELV3UH4cLzTX4xNkJfKzDh7PPiHPtGN#ebh4cIT#3OqsDN73aBouVz3hcratfUCV1Phf" +
		"gUsxGVPCip5Ahmiyh2J5w1cf$M1TF5QBaoi5rumu0#qhuzc8E5wAD$LOEQ#ZUeEUrmeOx7E" +
		"DFOXnvTd#gntsWZz0dyhTFpn$huaQE4Z1lD#RcVb3h7jLpQW7ggDjTB7nFjlQp1xh78ICMx" +
		"ojwR1FeGqktdCWhybGE#VGy1FsBLByh4txN1CxHFH4wcu6rNScfjGJ7qTqDUwo3Pmte8EWG" +
		"PB6VlJhFYxNltJOiiR#VWvxOxtgFUrr4AU8irWgUOm$3PntenO4tKdt6NjluhphsKT0vKsF" +
		"Mr6FlQ$aiq6RTxWJgPjcdO3syRrXoSaF8NK0wnt6z5KzOhVMnLfulWyMgyL5ZKaH#coFU#j" +
		"f6r9BwuCYNzrrmvCcBTKmHUH1xQ11eiSxhytgElsXvXuNj6eZBUDsUYTXGOrmhmH6l2zXn6" +
		"y6$0lyJ$0JuKQ9up3rXCNXRy2NW8t3kEeBF1OTT$0E8upDmsAQWBheFsd9RnMeRwuFD5$4T" +
		"KkCqozAbOugxixHjKyNZzwWQd908lWuSw#fURs4OkXwGhlLnvMsOY3ckAtJEiVhSZscz8Pg" +
		"$eFaUdQEqmBMXYJPR0$xl0VyWsBo24VI$XVukv2qU$BlWEedLzLn6Qxabw6FTrwcalgUqpR" +
		"O7v78umnMrd0Sv2nndsODxOE8pu9sHhszizhXN9grGxLBjT9zjBPAJmi$9c6nhtnrUb$IPf" +
		"jMO$r8Tun$mjxoaRXBslsSRkDZRMLQ$sFD9g9cUNKhsehwuAu5gADcTh$acpVy67T3pSjdc" +
		"tK7xAG86xj#UMq73zDY2m5ZYJgXxUj9Ew1O2Jzz$uvg9kGJgUd0UFJTQihUirIw5FUCjiib" +
		"uflJMKMsNtkFUDstZOqNT15y4li$MZ#SHx#7YETF#jwlxX0Vt1U$QOECwTkIDFWaSy$wbTT" +
		"RPyXiNg5Fg7VGTjsJw1BB7aesbWVh9s8#f9paNoGsWOrkRv9wGay2l07U3urab5SytoRXNf" +
		"9vXyzLAXS17#M$#YwSozBaNuvGpAXDt1g5QCqu#u#xA7K3jGTWzZEh7Cq05e8ay0TTSnXsD" +
		"n$9upk5inbC2ty9u3kIRGTVn8l7$6F3be34Wt2luCZx4U6vWr02#GshU3jh27$3rl90FyWP" +
		"8TuDU03tFQ$avVbP7kqRp0$mR$yg$yC$y4$$8#taVemRpDtBiQtwPN#9r$2BVnNUI$iV8DV" +
		"y0sil7#0XFuqbeNmhw67G927bZr03kpcz8VPntVXhq6g$dvNmhlyglyBUyctVnJZbUg75dy" +
		"PzycF$Wtz56FS1ibyd#fLp4tVWYjDf9kIttqHPzvNKUuox0M0o#MigpGTCPJnsSPyOyJ5w7" +
		"ya0jp#T7#67mX$X1eD$6ZylSFG5wb77luHscPJ$G59xCU$Wx$epnhCbNyQTwR3j$oTlu2$u" +
		"SxSTbrb5JU1K$nW$m$MZTn$Vo0ExF2tYGr1yYhuCPJqRSXc$YnMAjGDU2tkFDZBiglyDlyr" +
		"kyYT$azzNyfGsUfnZtFCRp5uy6ZTG36sWXhWlnxhGGRqzJmQVYVNigskAlZmKDAqP3$WlAb" +
		"Rz0kV0cPk0jJ57$OZGAuwFmVf#FTZxQ#RezpKR3WJCSV11e1CP7G1wCjY2nHddWSoIvg12y" +
		"4EE5Q5#5jfqcehytU6$9LRkVZVe4eKdGiyYGD07O4o0BcWzPq2KKZpT40XaW5qZ8YPG3EGT" +
		"wEUZBGLzWEu7wegt808dVDmXaK07Q1T0Hlz89wW6vfwHucW5PqAMmNm3R1UWND1bzao5FXe" +
		"wYHBeSVOBcIdBH6EYDaJmU97xfSz5bw1i0Fa3#xYBUvUDDFXRS8eF6WmiQPwDkcYwMvAAPq" +
		"FFJR4akceSnHV4sIfIK3R$PUAlEHbysv5cmcIL$Ot61ucae#53eZ4R$QBJzD18wuSbr4agG" +
		"VD5$0B9qNu0=");

	private WorkingParseResult fWorking;

	// suppress the error printouts
	private class CoffeeEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
			if (token == null || fWorking == null)
			{
				return;
			}
			fWorking.addError(new ParseError(ICoffeeConstants.CONTENT_TYPE_COFFEE, token, IParseError.Severity.ERROR));
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}

    public synchronized ParseResult parse(IParseState parseState) throws java.lang.Exception
    {
        WorkingParseResult working = new WorkingParseResult();
        parse(parseState, working);
        return working.getImmutableResult();
    }
    
    
	protected synchronized void parse(IParseState parseState, WorkingParseResult working) throws java.lang.Exception
	{
		fWorking = working;
		
		try
		{
    		// make sure we have some source
    		String source = parseState.getSource();
    
    		// create scanner and send source to it
    		CoffeeScanner scanner = new CoffeeScanner();
    		scanner.setSource(source);
    
			// parse
			ParseRootNode result = (ParseRootNode) parse(scanner);
			int start = parseState.getStartingOffset();
			int end = start + parseState.getSource().length() - 1;
			result.setLocation(start, end);

			// store results in the parse state
			working.setParseResult(result);

			// attach comments to parse root node
			result.setCommentNodes(scanner.getComments().toArray(new IParseNode[scanner.getComments().size()]));
		}
		finally
		{
			fWorking = null;
		}
	}

	public CoffeeParser() {
		super(PARSING_TABLES);


		report = new CoffeeEvents();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // Root = 
			{
					
			return new CoffeeParseRootNode();
			}
			case 1: // Root = Body.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
			return new CoffeeParseRootNode(b);
			}
			case 2: // Root = Block.b TERMINATOR
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
			return new CoffeeParseRootNode(b);
			}
			case 3: // Body = Line.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final CoffeeNode l = (CoffeeNode) _symbol_l.value;
					
			return new CoffeeBlockNode(l);
			}
			case 4: // Body = Body.b TERMINATOR Line.l
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final CoffeeNode l = (CoffeeNode) _symbol_l.value;
					
			b.addChild(l);
        	return b;
			}
			case 11: // Statement = STATEMENT.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final String s = (String) _symbol_s.value;
					
        	return new CoffeeLiteralNode(s);
			}
			case 23: // Block = INDENT OUTDENT
			{
					
        	return new CoffeeBlockNode();
			}
			case 24: // Block = INDENT Body.b OUTDENT
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return b;
			}
			case 25: // Identifier = IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					
        	return new CoffeeLiteralNode(i);
			}
			case 26: // AlphaNumeric = NUMBER.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					
        	return new CoffeeLiteralNode(n);
			}
			case 27: // AlphaNumeric = STRING.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final String s = (String) _symbol_s.value;
					
        	return new CoffeeLiteralNode(s);
			}
			case 29: // Literal = JS.j
			{
					final Symbol _symbol_j = _symbols[offset + 1];
					final String j = (String) _symbol_j.value;
					
        	return new CoffeeLiteralNode(j);
			}
			case 30: // Literal = REGEX.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final String r = (String) _symbol_r.value;
					
        	return new CoffeeLiteralNode(r);
			}
			case 31: // Literal = BOOL.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final String b = (String) _symbol_b.value;
					
	        CoffeeLiteralNode val = new CoffeeLiteralNode(b);
	        if (b == "undefined")
			{
	          val.isUndefined = true;
	        }
	        return val;
			}
			case 32: // Assign = Assignable.a EQUAL Expression.e
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeAssignNode(a, e);
			}
			case 33: // Assign = Assignable.a EQUAL INDENT Expression.e OUTDENT
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeAssignNode(a, e);
			}
			case 34: // AssignObj = ObjAssignable.o
			{
					final Symbol _symbol_o = _symbols[offset + 1];
					final CoffeeNode o = (CoffeeNode) _symbol_o.value;
					
        	return new CoffeeValueNode(o);
			}
			case 35: // AssignObj = ObjAssignable.o COLON Expression.e
			{
					final Symbol _symbol_o = _symbols[offset + 1];
					final CoffeeNode o = (CoffeeNode) _symbol_o.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeAssignNode(new CoffeeValueNode(o), e, "object");
			}
			case 36: // AssignObj = ObjAssignable.o COLON_SLASH INDENT Expression.e OUTDENT
			{
					final Symbol _symbol_o = _symbols[offset + 1];
					final CoffeeNode o = (CoffeeNode) _symbol_o.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeAssignNode(new CoffeeValueNode(o), e, "object");
			}
			case 41: // Return = RETURN Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeReturnNode(e);
			}
			case 42: // Return = RETURN
			{
					
        	return new CoffeeReturnNode();
			}
			case 43: // Comment = HERECOMMENT.h
			{
					final Symbol _symbol_h = _symbols[offset + 1];
					final String h = (String) _symbol_h.value;
					
        	return new CoffeeCommentNode(h);
			}
			case 44: // Code = PARAM_START ParamList.p PARAM_END FuncGlyph.f Block.b
			{
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final CoffeeParamNode[] p = _list_p == null ? new CoffeeParamNode[0] : (CoffeeParamNode[]) _list_p.toArray(new CoffeeParamNode[_list_p.size()]);
					final Symbol _symbol_f = _symbols[offset + 4];
					final String f = (String) _symbol_f.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeCodeNode(p, b, f);
			}
			case 45: // Code = FuncGlyph.f Block.b
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final String f = (String) _symbol_f.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeCodeNode(b, f);
			}
			case 46: // FuncGlyph = FUNC_ARROW
			{
					
        	return new Symbol("func");
			}
			case 47: // FuncGlyph = BOUND_FUNC_ARROW
			{
					
        	return new Symbol("boundfunc");
			}
			case 50: // ParamList = Param.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final CoffeeParamNode p = (CoffeeParamNode) _symbol_p.value;
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 51: // ParamList = ParamList.l COMMA Param.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final CoffeeParamNode[] l = _list_l == null ? new CoffeeParamNode[0] : (CoffeeParamNode[]) _list_l.toArray(new CoffeeParamNode[_list_l.size()]);
					final Symbol _symbol_p = _symbols[offset + 3];
					final CoffeeParamNode p = (CoffeeParamNode) _symbol_p.value;
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 52: // Param = ParamVar.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final CoffeeNode v = (CoffeeNode) _symbol_v.value;
					
        	return new CoffeeParamNode(v);
			}
			case 53: // Param = ParamVar.v ELLIPSIS
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final CoffeeNode v = (CoffeeNode) _symbol_v.value;
					
        	return new CoffeeParamNode(v, null, true);
			}
			case 54: // Param = ParamVar.v EQUAL Expression.e
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final CoffeeNode v = (CoffeeNode) _symbol_v.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeParamNode(v, e);
			}
			case 59: // Splat = Expression.e ELLIPSIS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeSplatNode(e);
			}
			case 60: // SimpleAssignable = Identifier.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final CoffeeLiteralNode i = (CoffeeLiteralNode) _symbol_i.value;
					
        	return new CoffeeValueNode(i);
			}
			case 61: // SimpleAssignable = Value.v Accessor.a
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final CoffeeValueNode v = (CoffeeValueNode) _symbol_v.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					
        	return v.push(a);
			}
			case 62: // SimpleAssignable = Invocation.i Accessor.a
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final CoffeeCallNode i = (CoffeeCallNode) _symbol_i.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					
        	return new CoffeeValueNode(i, a);
			}
			case 65: // Assignable = Array.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeArrNode a = (CoffeeArrNode) _symbol_a.value;
					
        	return new CoffeeValueNode(a);
			}
			case 66: // Assignable = Object.o
			{
					final Symbol _symbol_o = _symbols[offset + 1];
					final CoffeeObjNode o = (CoffeeObjNode) _symbol_o.value;
					
        	return new CoffeeValueNode(o);
			}
			case 68: // Value = Literal.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final CoffeeLiteralNode l = (CoffeeLiteralNode) _symbol_l.value;
					
        	return new CoffeeValueNode(l);
			}
			case 69: // Value = Parenthetical.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final CoffeeParensNode p = (CoffeeParensNode) _symbol_p.value;
					
        	return new CoffeeValueNode(p);
			}
			case 70: // Value = Range.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final CoffeeRangeNode r = (CoffeeRangeNode) _symbol_r.value;
					
        	return new CoffeeValueNode(r);
			}
			case 72: // Accessor = DOT Identifier.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final CoffeeLiteralNode i = (CoffeeLiteralNode) _symbol_i.value;
					
        	return new CoffeeAccessNode(i);
			}
			case 73: // Accessor = QUESTION_DOT Identifier.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final CoffeeLiteralNode i = (CoffeeLiteralNode) _symbol_i.value;
					
        	return new CoffeeAccessNode(i, "soak");
			}
			case 74: // Accessor = DOUBLE_COLON Identifier.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final CoffeeLiteralNode i = (CoffeeLiteralNode) _symbol_i.value;
					
        	return new CoffeeAccessNode(i, "proto");
			}
			case 75: // Accessor = DOUBLE_COLON
			{
					
        	return new CoffeeAccessNode(new CoffeeLiteralNode("prototype"));
			}
			case 77: // Index = INDEX_START IndexValue.v INDEX_END
			{
					final Symbol _symbol_v = _symbols[offset + 2];
					final CoffeeIndexNode v = (CoffeeIndexNode) _symbol_v.value;
					
        	return v;
			}
			case 78: // Index = INDEX_SOAK Index.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final CoffeeIndexNode i = (CoffeeIndexNode) _symbol_i.value;
					
			i.soak = true;
			return i;
			}
			case 79: // Index = INDEX_PROTO Index.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final CoffeeIndexNode i = (CoffeeIndexNode) _symbol_i.value;
					
			i.proto = true;
			return i;
			}
			case 80: // IndexValue = Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeIndexNode(e);
			}
			case 81: // IndexValue = Slice.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final CoffeeRangeNode s = (CoffeeRangeNode) _symbol_s.value;
					
        	return new CoffeeSliceNode(s);
			}
			case 82: // Object = LCURLY AssignList.l OptComma.c RCURLY
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final String c = (String) _symbol_c.value;
					
        	return new CoffeeObjNode(c, l);
			}
			case 83: // AssignList = 
			{
					
        	return new Symbol(new ArrayList<CoffeeNode>());
			}
			case 84: // AssignList = AssignObj.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					
			ArrayList<CoffeeNode> lst = new ArrayList<CoffeeNode>();
       		lst.add(a);
       		return new Symbol(lst);
			}
			case 85: // AssignList = AssignList.l COMMA AssignObj.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					
       		l.add(a);
       	    return new Symbol(l);
			}
			case 86: // AssignList = AssignList.l OptComma TERMINATOR AssignObj.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					
			l.add(a);
       	    return new Symbol(l);
			}
			case 87: // AssignList = AssignList.l OptComma INDENT AssignList.a OptComma OUTDENT
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final List<CoffeeNode> a = (List<CoffeeNode>) _symbol_a.value;
					
			l.addAll(a);
       	    return new Symbol(l);
			}
			case 88: // Class = CLASS
			{
					
        	return new CoffeeClassNode();
			}
			case 89: // Class = CLASS Block.b
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeClassNode(null, null, b);
			}
			case 90: // Class = CLASS EXTENDS Value.v
			{
					final Symbol _symbol_v = _symbols[offset + 3];
					final CoffeeValueNode v = (CoffeeValueNode) _symbol_v.value;
					
        	return new CoffeeClassNode(null, v);
			}
			case 91: // Class = CLASS EXTENDS Value.v Block.b
			{
					final Symbol _symbol_v = _symbols[offset + 3];
					final CoffeeValueNode v = (CoffeeValueNode) _symbol_v.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeClassNode(null, v, b);
			}
			case 92: // Class = CLASS SimpleAssignable.s
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final CoffeeValueNode s = (CoffeeValueNode) _symbol_s.value;
					
        	return new CoffeeClassNode(s);
			}
			case 93: // Class = CLASS SimpleAssignable.s Block.b
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final CoffeeValueNode s = (CoffeeValueNode) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeClassNode(s, null, b);
			}
			case 94: // Class = CLASS SimpleAssignable.s EXTENDS Value.v
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final CoffeeValueNode s = (CoffeeValueNode) _symbol_s.value;
					final Symbol _symbol_v = _symbols[offset + 4];
					final CoffeeValueNode v = (CoffeeValueNode) _symbol_v.value;
					
        	return new CoffeeClassNode(s, v);
			}
			case 95: // Class = CLASS SimpleAssignable.s EXTENDS Value.v Block.b
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final CoffeeValueNode s = (CoffeeValueNode) _symbol_s.value;
					final Symbol _symbol_v = _symbols[offset + 4];
					final CoffeeValueNode v = (CoffeeValueNode) _symbol_v.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeClassNode(s, v, b);
			}
			case 96: // Invocation = Value.v OptFuncExist.o Arguments.a
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final CoffeeValueNode v = (CoffeeValueNode) _symbol_v.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final Boolean o = (Boolean) _symbol_o.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final List<CoffeeNode> a = (List<CoffeeNode>) _symbol_a.value;
					
        	return new CoffeeCallNode(v, a, o);
			}
			case 97: // Invocation = Invocation.i OptFuncExist.o Arguments.a
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final CoffeeCallNode i = (CoffeeCallNode) _symbol_i.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final Boolean o = (Boolean) _symbol_o.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final List<CoffeeNode> a = (List<CoffeeNode>) _symbol_a.value;
					
        	return new CoffeeCallNode(i, a, o);
			}
			case 98: // Invocation = SUPER
			{
					
			List<CoffeeNode> args = new ArrayList<CoffeeNode>();
			args.add(new CoffeeSplatNode(new CoffeeLiteralNode("arguments")));
        	return new CoffeeCallNode("super", args);
			}
			case 99: // Invocation = SUPER Arguments.a
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final List<CoffeeNode> a = (List<CoffeeNode>) _symbol_a.value;
					
        	return new CoffeeCallNode("super", a);
			}
			case 100: // OptFuncExist = 
			{
					
        	return new Symbol(false);
			}
			case 101: // OptFuncExist = FUNC_EXIST
			{
					
        	return new Symbol(true);
			}
			case 102: // Arguments = CALL_START CALL_END
			{
					
        	return new Symbol(new ArrayList<CoffeeNode>());
			}
			case 103: // Arguments = CALL_START ArgList.l OptComma CALL_END
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					
        	return new Symbol(l);
			}
			case 104: // This = THIS
			{
					
        	return new CoffeeValueNode(new CoffeeLiteralNode("this"));
			}
			case 105: // This = AT_SIGIL
			{
					
        	return new CoffeeValueNode(new CoffeeLiteralNode("this"));
			}
			case 106: // ThisProperty = AT_SIGIL Identifier.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final CoffeeLiteralNode i = (CoffeeLiteralNode) _symbol_i.value;
					
        	return new CoffeeValueNode(new CoffeeLiteralNode("this"), new CoffeeAccessNode(i), "this");
			}
			case 107: // Array = LBRACKET RBRACKET
			{
					
        	return new CoffeeArrNode(new ArrayList<CoffeeNode>());
			}
			case 108: // Array = LBRACKET ArgList.l OptComma RBRACKET
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					
        	return new CoffeeArrNode(l);
			}
			case 109: // RangeDots = DOT_DOT
			{
					
        	return new Symbol("inclusive");
			}
			case 110: // RangeDots = ELLIPSIS
			{
					
        	return new Symbol("exclusive");
			}
			case 111: // Range = LBRACKET Expression.e RangeDots.r Expression.x RBRACKET
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final String r = (String) _symbol_r.value;
					final Symbol _symbol_x = _symbols[offset + 4];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeRangeNode(e, x, r);
			}
			case 112: // Slice = Expression.e RangeDots.r Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final String r = (String) _symbol_r.value;
					final Symbol _symbol_x = _symbols[offset + 3];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeRangeNode(e, x, r);
			}
			case 113: // Slice = Expression.e RangeDots.r
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final String r = (String) _symbol_r.value;
					
        	return new CoffeeRangeNode(e, null, r);
			}
			case 114: // Slice = RangeDots.r Expression.e
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final String r = (String) _symbol_r.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeRangeNode(null, e, r);
			}
			case 115: // ArgList = Arg.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					
        	ArrayList<CoffeeNode> lst = new ArrayList<CoffeeNode>();
       		lst.add(a);
       		return new Symbol(lst);
			}
			case 116: // ArgList = ArgList.l COMMA Arg.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					
			l.add(a);
        	return new Symbol(l);
			}
			case 117: // ArgList = ArgList.l OptComma TERMINATOR Arg.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final CoffeeNode a = (CoffeeNode) _symbol_a.value;
					
			l.add(a);
        	return new Symbol(l);
			}
			case 118: // ArgList = INDENT ArgList.l OptComma OUTDENT
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					
        	return new Symbol(l);
			}
			case 119: // ArgList = ArgList.l OptComma INDENT ArgList.a OptComma OUTDENT
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List<CoffeeNode> l = (List<CoffeeNode>) _symbol_l.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final List<CoffeeNode> a = (List<CoffeeNode>) _symbol_a.value;
					
			l.addAll(a);
        	return new Symbol(l);
			}
			case 122: // SimpleArgs = Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	ArrayList<CoffeeNode> lst = new ArrayList<CoffeeNode>();
       		lst.add(e);
       		return new Symbol(lst);
			}
			case 123: // SimpleArgs = SimpleArgs.s COMMA Expression.e
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final List<CoffeeNode> s = (List<CoffeeNode>) _symbol_s.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
			s.add(e);
        	return new Symbol(s);
			}
			case 124: // Try = TRY Block.b
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeTryNode(b);
			}
			case 125: // Try = TRY Block.b Catch.c
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final CoffeeCatchNode c = (CoffeeCatchNode) _symbol_c.value;
					
        	return new CoffeeTryNode(b, c.getIdentifier(), c.getBlock());
			}
			case 126: // Try = TRY Block.b FINALLY Block.l
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final CoffeeBlockNode l = (CoffeeBlockNode) _symbol_l.value;
					
        	return new CoffeeTryNode(b, null, null, l);
			}
			case 127: // Try = TRY Block.b Catch.c FINALLY Block.l
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final CoffeeCatchNode c = (CoffeeCatchNode) _symbol_c.value;
					final Symbol _symbol_l = _symbols[offset + 5];
					final CoffeeBlockNode l = (CoffeeBlockNode) _symbol_l.value;
					
        	return new CoffeeTryNode(b, c.getIdentifier(), c.getBlock(), l);
			}
			case 128: // Catch = CATCH Identifier.i Block.b
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final CoffeeLiteralNode i = (CoffeeLiteralNode) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeCatchNode(i, b);
			}
			case 129: // Throw = THROW Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeThrowNode(e);
			}
			case 130: // Parenthetical = LPAREN Body.b RPAREN
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeParensNode(b);
			}
			case 131: // Parenthetical = LPAREN INDENT Body.b OUTDENT RPAREN
			{
					final Symbol _symbol_b = _symbols[offset + 3];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeParensNode(b);
			}
			case 132: // WhileSource = WHILE Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeWhileNode(e);
			}
			case 133: // WhileSource = WHILE Expression.e WHEN Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_x = _symbols[offset + 4];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeWhileNode(e, x);
			}
			case 134: // WhileSource = UNTIL Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeWhileNode(e, true);
			}
			case 135: // WhileSource = UNTIL Expression.e WHEN Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_x = _symbols[offset + 4];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeWhileNode(e, x, true);
			}
			case 136: // While = WhileSource.w Block.b
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final CoffeeWhileNode w = (CoffeeWhileNode) _symbol_w.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return w.addBody(b);
			}
			case 137: // While = Statement.s WhileSource.w
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final CoffeeNode s = (CoffeeNode) _symbol_s.value;
					final Symbol _symbol_w = _symbols[offset + 2];
					final CoffeeWhileNode w = (CoffeeWhileNode) _symbol_w.value;
					
        	return w.addBody(new CoffeeBlockNode(s));
			}
			case 138: // While = Expression.e WhileSource.w
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_w = _symbols[offset + 2];
					final CoffeeWhileNode w = (CoffeeWhileNode) _symbol_w.value;
					
        	return w.addBody(new CoffeeBlockNode(e));
			}
			case 139: // While = Loop.l
			{
					final Symbol l = _symbols[offset + 1];
					
        	return l;
			}
			case 140: // Loop = LOOP Block.b
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeWhileNode(new CoffeeLiteralNode("true")).addBody(b);
			}
			case 141: // Loop = LOOP Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeWhileNode(new CoffeeLiteralNode("true")).addBody(new CoffeeBlockNode(e));
			}
			case 142: // For = Statement.s ForBody.f
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final CoffeeNode s = (CoffeeNode) _symbol_s.value;
					final Symbol _symbol_f = _symbols[offset + 2];
					final CoffeeForSourceNode f = (CoffeeForSourceNode) _symbol_f.value;
					
        	return new CoffeeForNode(s, f);
			}
			case 143: // For = Expression.e ForBody.f
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_f = _symbols[offset + 2];
					final CoffeeForSourceNode f = (CoffeeForSourceNode) _symbol_f.value;
					
        	return new CoffeeForNode(e, f);
			}
			case 144: // For = ForBody.f Block.b
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final CoffeeForSourceNode f = (CoffeeForSourceNode) _symbol_f.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeForNode(b, f);
			}
			case 145: // ForBody = FOR Range.r
			{
					final Symbol _symbol_r = _symbols[offset + 2];
					final CoffeeRangeNode r = (CoffeeRangeNode) _symbol_r.value;
					
        	return new CoffeeForSourceNode(new CoffeeValueNode(r));
			}
			case 146: // ForBody = ForStart.f ForSource.s
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final CoffeeForVariablesNode f = (CoffeeForVariablesNode) _symbol_f.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final CoffeeForSourceNode s = (CoffeeForSourceNode) _symbol_s.value;
					
        	s.own = f.own;
        	s.name = f.getChild(0);
        	s.index = f.getChild(1);
        	return s;
			}
			case 147: // ForStart = FOR ForVariables.f
			{
					final Symbol _symbol_f = _symbols[offset + 2];
					final CoffeeForVariablesNode f = (CoffeeForVariablesNode) _symbol_f.value;
					
        	return f;
			}
			case 148: // ForStart = FOR OWN ForVariables.f
			{
					final Symbol _symbol_f = _symbols[offset + 3];
					final CoffeeForVariablesNode f = (CoffeeForVariablesNode) _symbol_f.value;
					
        	f.own = true;
        	return f;
			}
			case 150: // ForValue = Array.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeArrNode a = (CoffeeArrNode) _symbol_a.value;
					
        	return new CoffeeValueNode(a);
			}
			case 151: // ForValue = Object.o
			{
					final Symbol _symbol_o = _symbols[offset + 1];
					final CoffeeObjNode o = (CoffeeObjNode) _symbol_o.value;
					
        	return new CoffeeValueNode(o);
			}
			case 152: // ForVariables = ForValue.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final CoffeeNode f = (CoffeeNode) _symbol_f.value;
					
        	return new CoffeeForVariablesNode(f);
			}
			case 153: // ForVariables = ForValue.f COMMA ForValue.v
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final CoffeeNode f = (CoffeeNode) _symbol_f.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final CoffeeNode v = (CoffeeNode) _symbol_v.value;
					
        	return new CoffeeForVariablesNode(f, v);
			}
			case 154: // ForSource = FORIN Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeForSourceNode(e);
			}
			case 155: // ForSource = FOROF Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeForSourceNode(e, true);
			}
			case 156: // ForSource = FORIN Expression.e WHEN Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_x = _symbols[offset + 4];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
			return new CoffeeForSourceNode(e, x);
			}
			case 157: // ForSource = FOROF Expression.e WHEN Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_x = _symbols[offset + 4];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
			return new CoffeeForSourceNode(e, x, true);
			}
			case 158: // ForSource = FORIN Expression.e BY Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_x = _symbols[offset + 4];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
			return new CoffeeForSourceNode(e, null, x);
			}
			case 159: // ForSource = FORIN Expression.e WHEN Expression.x BY Expression.p
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_x = _symbols[offset + 4];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					final Symbol _symbol_p = _symbols[offset + 6];
					final CoffeeNode p = (CoffeeNode) _symbol_p.value;
					
			return new CoffeeForSourceNode(e, x, p);
			}
			case 160: // ForSource = FORIN Expression.e BY Expression.x WHEN Expression.p
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_x = _symbols[offset + 4];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					final Symbol _symbol_p = _symbols[offset + 6];
					final CoffeeNode p = (CoffeeNode) _symbol_p.value;
					
			return new CoffeeForSourceNode(e, p, x);
			}
			case 161: // Switch = SWITCH Expression.e INDENT Whens.w OUTDENT
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_w = _symbols[offset + 4];
					final List<CoffeeWhenNode> w = (List<CoffeeWhenNode>) _symbol_w.value;
					
        	return new CoffeeSwitchNode(e, w);
			}
			case 162: // Switch = SWITCH Expression.e INDENT Whens.w ELSE Block.b OUTDENT
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_w = _symbols[offset + 4];
					final List<CoffeeWhenNode> w = (List<CoffeeWhenNode>) _symbol_w.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeSwitchNode(e, w, b);
			}
			case 163: // Switch = SWITCH INDENT Whens.w OUTDENT
			{
					final Symbol _symbol_w = _symbols[offset + 3];
					final List<CoffeeWhenNode> w = (List<CoffeeWhenNode>) _symbol_w.value;
					
        	return new CoffeeSwitchNode(null, w);
			}
			case 164: // Switch = SWITCH INDENT Whens.w ELSE Block.b OUTDENT
			{
					final Symbol _symbol_w = _symbols[offset + 3];
					final List<CoffeeWhenNode> w = (List<CoffeeWhenNode>) _symbol_w.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeSwitchNode(null, w, b);
			}
			case 165: // Whens = When.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final CoffeeWhenNode w = (CoffeeWhenNode) _symbol_w.value;
					
			ArrayList<CoffeeWhenNode> lst = new ArrayList<CoffeeWhenNode>();
       		lst.add(w);
       		return new Symbol(lst);
			}
			case 166: // Whens = Whens.s When.w
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final List<CoffeeWhenNode> s = (List<CoffeeWhenNode>) _symbol_s.value;
					final Symbol _symbol_w = _symbols[offset + 2];
					final CoffeeWhenNode w = (CoffeeWhenNode) _symbol_w.value;
					
			s.add(w);
        	return new Symbol(s);
			}
			case 167: // When = LEADING_WHEN SimpleArgs.a Block.b
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final List<CoffeeNode> a = (List<CoffeeNode>) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeWhenNode(a, b);
			}
			case 168: // When = LEADING_WHEN SimpleArgs.a Block.b TERMINATOR
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final List<CoffeeNode> a = (List<CoffeeNode>) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeWhenNode(a, b);
			}
			case 169: // IfBlock = IF.i Expression.e Block.b
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return new CoffeeIfNode(e, b, i);
			}
			case 170: // IfBlock = IfBlock.i ELSE IF.f Expression.e Block.b
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final CoffeeIfNode i = (CoffeeIfNode) _symbol_i.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return i.addElse(new CoffeeIfNode(e, b, f));
			}
			case 172: // If = IfBlock.i ELSE Block.b
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final CoffeeIfNode i = (CoffeeIfNode) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final CoffeeBlockNode b = (CoffeeBlockNode) _symbol_b.value;
					
        	return i.addElse(b);
			}
			case 173: // If = Statement.s POST_IF.p Expression.e
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final CoffeeNode s = (CoffeeNode) _symbol_s.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final String p = (String) _symbol_p.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeIfNode(e, new CoffeeBlockNode(s), p, true);
			}
			case 174: // If = Expression.e POST_IF.p Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final String p = (String) _symbol_p.value;
					final Symbol _symbol_x = _symbols[offset + 3];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeIfNode(x, new CoffeeBlockNode(e), p, true);
			}
			case 175: // Operation = UNARY.u Expression.e
			{
					final Symbol _symbol_u = _symbols[offset + 1];
					final String u = (String) _symbol_u.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return CoffeeOpNode.create(u, e, null);
			}
			case 176: // Operation = MINUS Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeOpNode("-", e);
			}
			case 177: // Operation = PLUS Expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeOpNode("+", e);
			}
			case 178: // Operation = MINUS_MINUS SimpleAssignable.s
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final CoffeeValueNode s = (CoffeeValueNode) _symbol_s.value;
					
        	return new CoffeeOpNode("--", s);
			}
			case 179: // Operation = PLUS_PLUS SimpleAssignable.s
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final CoffeeValueNode s = (CoffeeValueNode) _symbol_s.value;
					
        	return new CoffeeOpNode("++", s);
			}
			case 180: // Operation = SimpleAssignable.a MINUS_MINUS
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeValueNode a = (CoffeeValueNode) _symbol_a.value;
					
			return new CoffeeOpNode("--", a, null, true);
			}
			case 181: // Operation = SimpleAssignable.a PLUS_PLUS
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeValueNode a = (CoffeeValueNode) _symbol_a.value;
					
        	return new CoffeeOpNode("++", a, null, true);
			}
			case 182: // Operation = Expression.e QUESTION
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeExistenceNode(e);
			}
			case 183: // Operation = Expression.e PLUS Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_x = _symbols[offset + 3];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeOpNode("+", e, x);
			}
			case 184: // Operation = Expression.e MINUS Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_x = _symbols[offset + 3];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeOpNode("-", e, x);
			}
			case 185: // Operation = Expression.e MATH.m Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final String m = (String) _symbol_m.value;
					final Symbol _symbol_x = _symbols[offset + 3];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeOpNode(m, e, x);
			}
			case 186: // Operation = Expression.e SHIFT.s Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					final Symbol _symbol_x = _symbols[offset + 3];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeOpNode(s, e, x);
			}
			case 187: // Operation = Expression.e COMPARE.c Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final String c = (String) _symbol_c.value;
					final Symbol _symbol_x = _symbols[offset + 3];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeOpNode(c, e, x);
			}
			case 188: // Operation = Expression.e LOGIC.l Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_x = _symbols[offset + 3];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	return new CoffeeOpNode(l, e, x);
			}
			case 189: // Operation = Expression.e RELATION.r Expression.x
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final String r = (String) _symbol_r.value;
					final Symbol _symbol_x = _symbols[offset + 3];
					final CoffeeNode x = (CoffeeNode) _symbol_x.value;
					
        	if (r.charAt(0) == '!')
			{
          		return new CoffeeOpNode(r.substring(1), e, x).invert();
        	}
			else
			{
          		return CoffeeOpNode.create(r, e, x);
        	}
			}
			case 190: // Operation = SimpleAssignable.a COMPOUND_ASSIGN.c Expression.e
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeValueNode a = (CoffeeValueNode) _symbol_a.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final String c = (String) _symbol_c.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeAssignNode(a, e, c);
			}
			case 191: // Operation = SimpleAssignable.a COMPOUND_ASSIGN.c INDENT Expression.e OUTDENT
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeValueNode a = (CoffeeValueNode) _symbol_a.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final String c = (String) _symbol_c.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeAssignNode(a, e, c);
			}
			case 192: // Operation = SimpleAssignable.a EXTENDS Expression.e
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final CoffeeValueNode a = (CoffeeValueNode) _symbol_a.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CoffeeNode e = (CoffeeNode) _symbol_e.value;
					
        	return new CoffeeExtendsNode(a, e);
			}
			case 48: // OptComma = 
			{
				return new Symbol(null);
			}
			case 5: // Body = Body.b TERMINATOR
			case 6: // Line = Expression
			case 7: // Line = Statement
			case 8: // Statement = Return
			case 9: // Statement = Throw
			case 10: // Statement = Comment
			case 12: // Expression = Value
			case 13: // Expression = Invocation
			case 14: // Expression = Code
			case 15: // Expression = Operation
			case 16: // Expression = Assign
			case 17: // Expression = If
			case 18: // Expression = Try
			case 19: // Expression = While
			case 20: // Expression = For
			case 21: // Expression = Switch
			case 22: // Expression = Class
			case 28: // Literal = AlphaNumeric
			case 37: // AssignObj = Comment
			case 38: // ObjAssignable = Identifier
			case 39: // ObjAssignable = AlphaNumeric
			case 40: // ObjAssignable = ThisProperty
			case 49: // OptComma = COMMA
			case 55: // ParamVar = Identifier
			case 56: // ParamVar = ThisProperty
			case 57: // ParamVar = Array
			case 58: // ParamVar = Object
			case 63: // SimpleAssignable = ThisProperty
			case 64: // Assignable = SimpleAssignable
			case 67: // Value = Assignable
			case 71: // Value = This
			case 76: // Accessor = Index
			case 120: // Arg = Expression
			case 121: // Arg = Splat
			case 149: // ForValue = Identifier
			case 171: // If = IfBlock
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
